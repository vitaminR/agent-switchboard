#!/usr/bin/env node
/**
 * Agent Switchboard â€” Redis MCP Server
 * Tools: ping, publish, xadd, xread, xgroup_create, xreadgroup, xack, xpending
 * Transport: stdio (Claude Code, Gemini Code Assist, Copilot compatible)
 */
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { createClient } from "redis";

// Config
const REDIS_URL = process.env.REDIS_URL || "redis://127.0.0.1:6379";
const DEFAULT_EVENTS_STREAM = process.env.AGENT_EVENTS_STREAM || "agent:events";
const DEFAULT_SESSION_STREAM = process.env.AGENT_SESSION_STREAM || "agent:session_log"; // reserved for future use
const DEFAULT_GROUP = process.env.AGENT_CONSUMER_GROUP || "triage";
const DEFAULT_CONSUMER = process.env.AGENT_CONSUMER_NAME || "worker-1";

// Redis client
const redis = createClient({ url: REDIS_URL });
await redis.connect();

// MCP server
const server = new Server({ name: "agent-switchboard-mcp", version: "0.3.0" }, { capabilities: { tools: {} } });

// Health
server.addTool({
  name: "redis_ping",
  description: "Ping the Redis server",
  inputSchema: { type: "object", properties: {} },
  handler: async () => ({ pong: await redis.ping() })
});

// Pub/Sub
server.addTool({
  name: "redis_publish",
  description: "Publish to a Redis pub/sub channel",
  inputSchema: {
    type: "object",
    properties: { channel: { type: "string" }, message: { type: "string" } },
    required: ["channel", "message"]
  },
  handler: async ({ channel, message }) => {
    const n = await redis.publish(channel, message);
    return { ok: true, subscribers: n };
  }
});

// Streams: XADD
server.addTool({
  name: "redis_xadd",
  description: "Append an entry to a Redis stream",
  inputSchema: {
    type: "object",
    properties: {
      stream: { type: "string", default: DEFAULT_EVENTS_STREAM },
      fields: { type: "object", description: "Key-value map" },
      id: { type: "string", description: "Optional ID; default *" }
    },
    required: ["fields"]
  },
  handler: async ({ stream = DEFAULT_EVENTS_STREAM, fields, id }) => {
    const newId = await redis.xAdd(stream, id || "*", fields);
    return { ok: true, stream, id: newId };
  }
});

// Streams: XREAD (non-group)
server.addTool({
  name: "redis_xread",
  description: "Read from a Redis stream (non-group)",
  inputSchema: {
    type: "object",
    properties: {
      stream: { type: "string", default: DEFAULT_EVENTS_STREAM },
      last_id: { type: "string", default: "$" },
      block_ms: { type: "number", default: 0 },
      count: { type: "number", default: 1 }
    }
  },
  handler: async ({ stream = DEFAULT_EVENTS_STREAM, last_id = "$", block_ms = 0, count = 1 }) => {
    const opts = { COUNT: count };
    if ((block_ms | 0) > 0) opts.BLOCK = block_ms | 0;
    const res = await redis.xRead([{ key: stream, id: last_id }], opts);
    return { ok: true, data: res || [] };
  }
});

// Consumer groups: XGROUP CREATE
server.addTool({
  name: "redis_xgroup_create",
  description: "Create a consumer group on a stream",
  inputSchema: {
    type: "object",
    properties: {
      stream: { type: "string", default: DEFAULT_EVENTS_STREAM },
      group: { type: "string", default: DEFAULT_GROUP },
      id: { type: "string", default: "$" },
      mkstream: { type: "boolean", default: true }
    }
  },
  handler: async ({ stream = DEFAULT_EVENTS_STREAM, group = DEFAULT_GROUP, id = "$", mkstream = true }) => {
    try {
      await redis.xGroupCreate(stream, group, id, { MKSTREAM: !!mkstream });
      return { ok: true, stream, group, id };
    } catch (e) {
      if (String(e).includes("BUSYGROUP")) return { ok: true, stream, group, id, note: "Group already exists" };
      throw e;
    }
  }
});

// XREADGROUP
server.addTool({
  name: "redis_xreadgroup",
  description: "Read from a stream using a consumer group",
  inputSchema: {
    type: "object",
    properties: {
      stream: { type: "string", default: DEFAULT_EVENTS_STREAM },
      group: { type: "string", default: DEFAULT_GROUP },
      consumer: { type: "string", default: DEFAULT_CONSUMER },
      count: { type: "number", default: 1 },
      block_ms: { type: "number", default: 15000 },
      id: { type: "string", default: ">" }
    }
  },
  handler: async ({ stream = DEFAULT_EVENTS_STREAM, group = DEFAULT_GROUP, consumer = DEFAULT_CONSUMER, count = 1, block_ms = 15000, id = ">" }) => {
    const opts = { COUNT: count };
    if ((block_ms | 0) > 0) opts.BLOCK = block_ms | 0;
    const res = await redis.xReadGroup(group, consumer, [{ key: stream, id }], opts);
    return { ok: true, data: res || [] };
  }
});

// XACK
server.addTool({
  name: "redis_xack",
  description: "Acknowledge one or more messages in a group",
  inputSchema: {
    type: "object",
    properties: {
      stream: { type: "string", default: DEFAULT_EVENTS_STREAM },
      group: { type: "string", default: DEFAULT_GROUP },
      ids: { type: "array", items: { type: "string" } }
    },
    required: ["ids"]
  },
  handler: async ({ stream = DEFAULT_EVENTS_STREAM, group = DEFAULT_GROUP, ids }) => {
    const count = await redis.xAck(stream, group, ...ids);
    return { ok: true, acknowledged: count };
  }
});

// XPENDING
server.addTool({
  name: "redis_xpending",
  description: "Inspect pending messages for a group",
  inputSchema: {
    type: "object",
    properties: {
      stream: { type: "string", default: DEFAULT_EVENTS_STREAM },
      group: { type: "string", default: DEFAULT_GROUP }
    }
  },
  handler: async ({ stream = DEFAULT_EVENTS_STREAM, group = DEFAULT_GROUP }) => {
    const info = await redis.xPending(stream, group);
    return { ok: true, pending: info };
  }
});

// Start
const transport = new StdioServerTransport();
await server.connect(transport);
console.error("[agent-switchboard] MCP server started.", { REDIS_URL, DEFAULT_EVENTS_STREAM, DEFAULT_GROUP, DEFAULT_CONSUMER });
